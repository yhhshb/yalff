## Introduction

YALFF (Yet Another Lossy FASTQ Filter) is a lossy compressor for fastq files which uses a Burrows and Wheeler Transform as an index.
This greatly reduces the amount of memory required compared to other tools such as [QUARTZ][1].

## Availability

YALFF is released under [GPLv3][2].
Because YALFF uses some BWA functions and the same format for the index, it requires the [zlib][3] dependency.

## Usage

YALFF preserves the orders of the reads of the input files so there is no need for a paired end mode.

* Smoothing a fastq file:
    
        cat file.fastq | ./yalff -d index.fa > file_smoothed.fastq
    
* Smoothing a gzipped fastq file:

        zcat file.fastq.gz | ./yalff -d index.fa | gzip > file_smoothed.fastq.gz
        
* Smoothing using an index loaded in shared memory:

        bwa shm index.fa
        zcat file.fastq.gz | ./yalff -shm index.fa | gzip > file_smoothed.fastq.gz
        bwa shm -d
        
* Other options available are:

        -k NUM	 k-mer length. [32] (max = 255 excluded)

        -m NUM	 Number of mismatches allowed per k-mer. [1]

        -c NUM	 Chunk size. The number of reads read at once on each iteration. [10000]

        -b CHAR	 Sanger threshold for a quality score to be considered. [$]

        -g CHAR	 Sanger threshold for a quality score to be considered correct independently from the dictionary. [I]

        -s NUM	 Number of bases to skip after each k-mer. A value of 0 checks all the k-mers. [0]

        -q CHAR	 Sanger value used as replacement during smoothing. [I]

        -e CHAR	 Sanger value used as an eventual replacement when a k-mer aligns badly. [j]

        -t NUM	 Number of threads available. [Hardware concurrency - 1]
        
        -a NUM	 Smoothing algorithm. 0 checks all and only the k-mers considered. 1 applies a seed and extend search if a k-mer has no mismatches. [0]

        -h       See this help.

* It is also possible to reassemble a k-mer dictionary with the [assembler][4] developed for the [ProPhyle][5] package. 
  In this case you can pipe the k-mer stream directly into the ProphAsm assembler. 
  For this purpose the script folder contains the utility print_mitdb.c to print the k-mers of the dictionaries generated by Quartz and LAVA. 

[1]: http://cb.csail.mit.edu/cb/quartz
[2]: http://en.wikipedia.org/wiki/GNU_General_Public_License
[3]: http://zlib.net
[4]: https://github.com/prophyle/prophasm
[5]: https://prophyle.github.io
